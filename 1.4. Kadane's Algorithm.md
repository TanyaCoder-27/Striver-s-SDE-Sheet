# 1.4. Kadane's Algorithm

## ğŸ”¹ Logic Breakdown (Kadaneâ€™s Algorithm)
Kadaneâ€™s Algorithm works by maintaining:
1ï¸âƒ£ sum â†’ Tracks the running sum of the current subarray.
2ï¸âƒ£ max_sum â†’ Stores the highest subarray sum encountered so far.

## Step-by-Step Execution
- Add the current element (nums[i]) to sum â†’ Expanding the subarray.
- Update max_sum â†’ If sum is larger than previous max_sum, update it.
- If sum < 0, reset sum = 0 â†’ Since a negative sum will always decrease future sums, restart the subarray.

## ğŸ§  How to Memorize?
Use the "Expand â†’ Update â†’ Reset" trick:
1ï¸âƒ£ Expand: sum += nums[i] â†’ Extend the current subarray.
2ï¸âƒ£ Update: max_sum = Math.max(sum, max_sum) â†’ Check if this is the largest sum so far.
3ï¸âƒ£ Reset: if (sum < 0) sum = 0; â†’ If sum turns negative, discard it.
ğŸ’¡ Think of it like running a race:
- Expand â†’ Keep running forward (add elements to sum).
- Update â†’ Track your best performance (max_sum).
- Reset â†’ If you get tired (negative sum), start fresh instead of carrying a burden.

## âš ï¸ What Happens if We Change the Statement Order?
### Case 1: If we swap max_sum = Math.max(sum, max_sum); and if (sum < 0) sum = 0;
if(sum < 0){ 
    sum = 0; 
}
max_sum = Math.max(sum, max_sum);
ğŸ”´ Incorrect!
âŒ If sum < 0, we reset it first, meaning we might lose the opportunity to record the correct max_sum before resetting.
âŒ This fails for cases where a negative value is part of the max subarray.

nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
Expected max sum = 6 ([4, -1, 2, 1]), but wrong order could cause errors.

## ğŸš€ Final Takeaways
âœ… Correct order:
1ï¸âƒ£ Expand (sum += nums[i])
2ï¸âƒ£ Update (max_sum = Math.max(sum, max_sum))
3ï¸âƒ£ Reset if needed (if (sum < 0) sum = 0)
ğŸ”¹ Use "Expand â†’ Update â†’ Reset" to memorize it easily!
ğŸ”¹ Changing the order incorrectly can lose tracking of max_sum before resetting.

```
class Solution {
    public int maxSubArray(int[] nums) {
        int sum = 0;
        int n = nums.length;
        int max_sum = Integer.MIN_VALUE;
        for(int i=0;i<n;i++){
            sum += nums[i];
 
            max_sum = Math.max(sum,max_sum);
            
            if(sum < 0){
                sum =0;
            }

        }
      
        return max_sum;
    }
}

```


