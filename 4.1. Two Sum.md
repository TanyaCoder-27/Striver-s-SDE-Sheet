# 4.1. Two Sum

Using a **HashMap-based approach** to efficiently solve the **Two Sum** problem in **O(N) time complexity**. Letâ€™s break it down and create a **memorization technique** for easy recall.

---

## **ğŸ”¹ Explanation & Logic**
The goal is to find **two indices** in `nums[]` whose elements sum up to `target`.

### **ğŸš€ Step-by-Step Execution**
1ï¸âƒ£ **Initialize a HashMap (`map`)**  
   - The **key** stores numbers from the array (`nums[i]`).  
   - The **value** stores their index (`i`).  

2ï¸âƒ£ **Iterate through the array (`for` loop)**  
   - Compute the **complement** (`comp = target - nums[i]`), meaning the number we need to complete the sum.
   - **If `comp` already exists in `map`**, we return **its index** (`map.get(comp)`) along with the current index (`i`).
   - **Otherwise, store `nums[i]` in `map`** for future lookups.

3ï¸âƒ£ **Return `{ -1, -1 }` if no valid pair is found.**  

---

### **ğŸ“Œ Example Walkthrough**
#### **Input:**  
```java
nums = [2, 7, 11, 15], target = 9
```
#### **Processing:**
1. `map = {}` (empty at start)  
2. `i = 0, nums[0] = 2` â†’ Compute `comp = 9 - 2 = 7`  
   - **Not in `map`, so store `{2: 0}`**  
3. `i = 1, nums[1] = 7` â†’ Compute `comp = 9 - 7 = 2`  
   - **Found `comp` in `map`, return `{0, 1}`**  

âœ… **Correct Output:** `{0, 1}`

---

## **ğŸ§  Memorization Trick**
Use **"Store â†’ Check Complement â†’ Return Indices"**:
1ï¸âƒ£ **Store** values in HashMap.  
2ï¸âƒ£ **Check complement (`target - nums[i]`) exists in map**.  
3ï¸âƒ£ **Return indices when match found**.  

ğŸ’¡ **Think of this like finding a missing puzzle piece!**
- **Store known pieces (`nums[i]`) in `map`**  
- **Look for the missing piece (`target - nums[i]`)**  
- **If found, return both indices**  

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<>(); 
        //(key,val) -> (element,index)

        for(int i=0;i<nums.length;i++){
            int comp = target - nums[i];

            if(map.containsKey(comp)){
                return new int[]{map.get(comp),i};  //returning indices
            }

            map.put(nums[i],i);
        }

        return new int[]{-1,-1};
    }
}

```
