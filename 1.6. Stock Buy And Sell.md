# 1.6. Stock Buy And Sell

## Implementing Best Time to Buy and Sell Stock, a classic Greedy Algorithm problem. This solution efficiently finds the maximum profit you can achieve by buying and selling once in O(n) time and O(1) space. Letâ€™s break it down step by step, create a memorization trick, and explain why it works.

### ğŸ”¹ Explanation & Logic
The goal is to determine the maximum profit from a list of stock prices where: 1ï¸âƒ£ You can buy only once.
2ï¸âƒ£ You can sell only once.
3ï¸âƒ£ You must buy before selling.
### ğŸš€ Step-by-Step Execution
- Initialize variables:
- max_profit = 0 â†’ Stores the highest profit encountered so far.
- min_ele = prices[0] â†’ Tracks the minimum price seen so far.
- profit = 0 â†’ Tracks potential profit at each step.
- Iterate over prices starting from day 1 (i = 1)
- Calculate profit:
profit = prices[i] - min_ele
- Checks how much profit can be made if sold today.
- Update max_profit with the highest profit so far:
max_profit = Math.max(max_profit, profit)
- Update min_ele to track the lowest price:
min_ele = Math.min(min_ele, prices[i])
- This ensures we're always buying at the lowest price before selling.
- Return max_profit after processing all days.

### ğŸ§  Memorization Trick
Use "Track Min â†’ Compute Profit â†’ Update Max" to remember the sorting order!
ğŸ”¹ Track Min (min_ele) â†’ Keep track of the lowest price encountered so far.
ğŸ”¹ Compute Profit (prices[i] - min_ele) â†’ Check today's possible profit.
ğŸ”¹ Update Max (max_profit) â†’ Keep track of the best profit seen.
ğŸ’¡ Think of it like shopping for stocks:
- Track Min â†’ Find the lowest possible price to buy.
- Compute Profit â†’ See how much youâ€™d gain if you sell now.
- Update Max â†’ Keep track of the best deal possible.

### ğŸ“Œ Why This Works?
âœ… Single-pass O(n) traversal â†’ No nested loops.
âœ… No extra space O(1) â†’ We only use variables.
âœ… Handles edge cases efficiently (only one price, no profit case).

### ğŸ’¡ Example Walkthrough
Input:
prices = [7, 1, 5, 3, 6, 4]
Processing:
min_ele = 7, max_profit = 0
Day 1: Price = 1 â†’ min_ele = 1
Day 2: Price = 5 â†’ profit = 5 - 1 = 4 â†’ max_profit = 4
Day 3: Price = 3 â†’ profit = 3 - 1 = 2 â†’ (max_profit stays 4)
Day 4: Price = 6 â†’ profit = 6 - 1 = 5 â†’ max_profit = 5
Day 5: Price = 4 â†’ profit = 4 - 1 = 3 â†’ (max_profit stays 5)
Final max_profit = 5
âœ… Correct Answer: 5 (Buy at 1, Sell at 6)

```
class Solution {
    public int maxProfit(int[] prices) {
        int max_profit =0;
        int min_ele = prices[0];
        int profit =0;
        for(int i=1;i<prices.length;i++){
            profit = prices[i] - min_ele;

            max_profit = Math.max(max_profit,profit);
            min_ele = Math.min(min_ele,prices[i]);
        }
        return max_profit;
    }
}


```

