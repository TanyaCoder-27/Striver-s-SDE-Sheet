# 1.5.Sort an array of 0s, 1s and 2s

Implementing Dutch National Flag Algorithm, a super-efficient way to sort an array containing only 0, 1, and 2 in O(n) time and O(1) space. Letâ€™s break it down step-by-step, create a memorization trick, and explain why it works.

## ğŸ”¹ Explanation & Logic
The goal is to sort the array in a single pass using three pointers: 1ï¸âƒ£ low â†’ Marks the boundary where 0s should be placed.
2ï¸âƒ£ mid â†’ The main iterator for processing elements.
3ï¸âƒ£ high â†’ Marks the boundary where 2s should be placed.
ğŸš€ Step-by-Step Execution
- Initialize pointers:
- low = 0 (for 0s)
- mid = 0 (current element being processed)
- high = n - 1 (for 2s)
- Process elements using while(mid <= high)
- If nums[mid] == 0 â†’ Swap nums[mid] and nums[low], then move both pointers (low++, mid++).
- If nums[mid] == 1 â†’ mid++ (No swap needed, since 1 is already in the correct position).
- If nums[mid] == 2 â†’ Swap nums[mid] and nums[high], then only move high-- (Donâ€™t move mid yet because swapped value needs re-evaluation).
- Repeat until mid crosses high.

## ğŸ§  Memorization Trick
Use "0 â†’ Left, 2 â†’ Right, 1 â†’ Skip" to remember the sorting order!
ğŸ”¹ 0 â†’ Swap left (low++, mid++).
ğŸ”¹ 1 â†’ Skip (mid++).
ğŸ”¹ 2 â†’ Swap right (high-- only, donâ€™t increment mid immediately).
ğŸ“Œ Think of the pointers as segregating colors:
- Low boundary (low) keeps all 0s at the left.
- High boundary (high) keeps all 2s at the right.
- Mid processes the current element and adjusts accordingly.

## ğŸ“Œ Why This Works?
- âœ… Single-pass O(n) traversal (No nested loops).
- âœ… No extra space O(1) (In-place sorting).
- âœ… Handles edge cases efficiently (all 0s, all 2s, mixed order).

## ğŸ’¡ Example Walkthrough
Input:
nums = [2, 0, 2, 1, 1, 0]
Processing:
low = 0, mid = 0, high = 5
[2, 0, 2, 1, 1, 0] â†’ Swap `2` & `0` (high moves)
[0, 0, 2, 1, 1, 2] â†’ Swap `0` & `0` (low & mid move)
[0, 0, 2, 1, 1, 2] â†’ Mid encounters `2`, swap `2` & `1` (high moves)
[0, 0, 1, 1, 2, 2] â†’ Mid encounters `1`, just increment mid.
[0, 0, 1, 1, 2, 2] â†’ Fully sorted!

```
class Solution {
    public void sortColors(int[] nums) {
        int low =0;
        int mid = 0;
        int high = nums.length-1;

        while(mid<=high)
        {
            if(nums[mid] == 0){
                swap(nums,mid,low);
                low++;
                mid++;
            }
            else if(nums[mid] == 1){
                mid++;
            }
            else{
                swap(nums,mid,high);
                high--;
            }
        }
    }

    private static void swap(int[] arr,int l,int h){
        int temp = arr[l];
        arr[l] = arr[h];
        arr[h] = temp;
    }
}

```



